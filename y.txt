#. (a) Find the parametric equations of the tangent line to the following curves:
    i. r(t) = ln(t)i + e^(-t)j + t^3k; t0 = 2
    ii. r(t) = 2cos(pi*t)i + 2sin(pi*t)j + 3tk; t0 = 1/3

   (b) Find the vector parallel to the line of intersection of the two planes 3x - 6y - 2z = 15 and       2x + y - 2z = 5.

    (c) Find the velocity and acceleration of r(t) = 3ti + sin(t)j + t^2k as a function of theta(t). Also, plot the graph of theta(t) versus 1.


import numpy as np
import matplotlib.pyplot as plt
import sympy as sp
from sympy import symbols, sin, cos, tan, diff
#a)i)
print("First parametric equation")
t1=2
x1,y1,z1=np.log(t1),np.exp(-t1),t1^3
dx1,dy1,dz1=1/t1,-np.exp(t1),3*t1^2
print(f'x={x1}+{dx1}t')
print(f'y={y1}+{dy1}t')
print(f'z={z1}+{dz1}t')
#ii)
print("second parametric equation")
t1=1/3
x1,y1,z1=2*np.cos(np.pi*t1),2*np.sin(np.pi*t1),3*t1
dx1,dy1,dz1=-2*np.pi*np.sin(np.pi*t1),2*np.pi*np.cos(np.pi*t1),3
print(f'x={x1}+{dx1}t')
print(f'y={y1}+{dy1}t')
print(f'z={z1}+{dz1}t')
#(b)
n1=np.array([3,-6,-2])
n2=np.array([2,1,-2])
direction_vector=np.cross(n1,n2)
print("A vector parallel to the line inetersection:",direction_vector)
# (c)
#finding v and a as a function of theta
theta = symbols('theta')
r = sp.Matrix([3*theta, sin(theta), theta**2])
v = r.diff(theta)
a = v.diff(theta)
print("velocity:")
sp.pprint(v)
print("acceleration:")
sp.pprint(a)
#plotting theta vs t
t = sp.symbols('t')
r = sp.Matrix([3*t, sp.sin(t), t**2])
v = r.diff(t)      
a = v.diff(t)        
v_dot_a = v.dot(a)
v_mag = sp.sqrt(v.dot(v))
a_mag = sp.sqrt(a.dot(a))
cos_theta = v_dot_a / (v_mag * a_mag)  #angle=cos^(-1)((v.a)/|v||a|)
theta_expr = sp.acos(cos_theta)  # θ(t) in radians
theta_func = sp.lambdify(t, theta_expr, modules='numpy')#Convert to a numerical function
t_vals = np.linspace(-10, 10, 1000)
theta_vals = theta_func(t_vals)

plt.figure(figsize=(10, 5))
plt.plot(t_vals, theta_vals, color='purple')
plt.xlabel('t')
plt.ylabel('θ(t) [radians]')
plt.title('Angle θ(t) Between Velocity and Acceleration Vectors')
plt.grid(True)
plt.tight_layout()
plt.show()


# (a) Find the tangent vectors to the plane curve C defined by the vector function r(t) = 5cos(t)i + 4sin(t)j at the points where t = pi/4 and t = pi. Make a sketch of C, and display the position vectors r(pi/4) and r(pi), and the tangent vectors r'(pi/4) and r'(pi).

(b) A bug walks along the trunk of a tree following a path modeled by the circular helix r(t) = <cos(t), sin(t), t>. Find the arc length parameterization of the circular helix while starting the bug at the reference point (1,0,0). Also, compute the bug's final coordinates when the bug walks up the helix for a distance of 10 units and graphically show the obtained results.

a)
import numpy as np
import matplotlib.pyplot as plt
import sympy as sp
#rom sympy import symbols,sin,cos,diff

t=sp.symbols('t')
r=sp.Matrix([5*sp.cos(t),4*sp.sin(t)])
r_prime=r.diff(t)
tangent1 = r_prime.subs(t, np.pi/4)
tangent2 = r_prime.subs(t, np.pi)
print('First tangent:')
print(tangent1)
sp.pprint('second tangent:')
sp.pprint(tangent2)

#plotting
t_val=np.linspace(0,2*np.pi,100)
x_val=5*np.cos(t_val)
y_val=4*np.sin(t_val)

r_func=sp.lambdify(t,r,modules='numpy')
t1=np.pi/4
t2=np.pi
r1=r_func(t1)
r2=r_func(t2)
r_prime_func=sp.lambdify(t,r_prime,modules='numpy')
tangent1=r_prime_func(t1)
tangent2=r_prime_func(t2)

plt.plot(x_val,y_val)
plt.quiver(0,0,r1[0],r1[1],angles='xy',scale_units='xy',scale=1,color='r')
plt.quiver(0,0,r2[0],r2[1],angles='xy',scale_units='xy',scale=1,color='g')
plt.quiver(r1[0],r1[1],tangent1[0],tangent1[1],angles='xy',scale_units='xy',scale=1,color='r')
plt.quiver(r2[0],r2[1],tangent2[0],tangent2[1],angles='xy',scale_units='xy',scale=1,color='g')
plt.xlabel('x')
plt.ylabel('y')
plt.grid(True)
plt.show()

b)
import numpy as np
import sympy as sp
import matplotlib.pyplot as plt

# Symbolic definitions
s, t = sp.symbols('s t')
r_t = sp.Matrix([sp.cos(t), sp.sin(t), t])
r_prime = r_t.diff(t)
r_prime_norm = sp.sqrt(sum(comp**2 for comp in r_prime))  # sqrt(2)
s_expr = sp.integrate(r_prime_norm, (t, 0, t))            # s = sqrt(2)*t
t_expr = sp.solve(sp.Eq(s, s_expr), t)[0]          # t = s / sqrt(2)

# Arc length parameterization
r_s = r_t.subs(t, t_expr)
r_s = sp.simplify(r_s)

print("Arc length parameterization r(s):")
sp.pprint(r_s)

# Evaluate start and end point
s_final = 10
start = r_t.subs(t, 0)
end = r_s.subs(s, s_final)
# Numerical helix curve
t_vals = np.linspace(0, float(end[2]) + 2, 200)
x_vals, y_vals, z_vals = np.cos(t_vals), np.sin(t_vals), t_vals

# Plotting
fig = plt.figure(figsize=(8, 8))
ax = fig.add_subplot(111, projection='3d')
ax.plot(x_vals, y_vals, z_vals, label='Helix')
# Start and end points
ax.scatter(float(start[0]), float(start[1]), float(start[2]), color='r', s=100, label='Start (1,0,0)')
ax.scatter(float(end[0]), float(end[1]), float(end[2]), color='g', s=100, label='End after s=10')
# Labels
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_zlabel('z')
ax.legend()
plt.title('Helix with Arc Length Parameterization')
plt.show()

# Final position
print("Final position after walking 10 units:")
sp.pprint(end)


#3. (a) Compute T, N, B, kappa (κ), and tau (τ) for the curves:
    i. r(t) = e^t i + e^t cos(t) j + e^t sin(t) k; t = 0
    ii. r(t) = 2cos(t) i + 3sin(t) j; 0 <= t <= 2pi
    Also, plot the graphs of K(t) and hence comment on the obtained results.

(b) Justify whether or not the function f(x,y) = y^2 cos(x-y) satisfies the Laplace's equation and Cauchy-Riemann equations. Also, establish the identity f_xy = f_yx if possible.

(c) Suppose that w = sqrt(x^2 + y^2 + z^2), x = cos(theta), y = sin(theta), z = tan(theta). Use chain rule to find dw/d(theta) when theta = pi/4.

(d) The temperature (in degrees Celsius) at a point (x, y) on a metal plate in the xy-plane is stated as T(x,y) = 3x^2 y. Compute the gradient of T(x,y) at the point (-1, 3/2) and the directional derivative of T(x,y) at the point (-1, 3/2) in the direction (-1, -1/2). Also, plot the directional derivative with -2 <= x <= 0, 0 <= y <= 2, and visualize directional derivative over a surface.

(a)

import numpy as np
import sympy as sp
from sympy import symbols,sin,cos,diff,exp
import matplotlib.pyplot as plt

t= sp.symbols('t')
r1 = sp.Matrix([sp.exp(t), sp.exp(t) * sp.cos(t), sp.exp(t) * sp.sin(t)])
r2 = sp.Matrix([2 * sp.cos(t), 3 * sp.sin(t), 0])

def compute_frenet_serret(r):
    r_prime = r.diff(t)
    r_pprime = r_prime.diff(t)
    r_ppprime = r_pprime.diff(t)
    norm_rp=sp.sqrt(r_prime.dot(r_prime))
    #norm_rpp=sp.sqrt(r_pprime.dot(r_pprime))
    #norm_rppp=sp.sqrt(r_ppprime.dot(r_ppprime))
    T = r_prime / norm_rp        #T=r'(t)/|r'(t)|
    T_prime=T.diff(t)
    norm_Tp=sp.sqrt(T_prime.dot(T_prime))
    N = T_prime / norm_Tp         #N=T'(t)/|T'(t)|
    B = T.cross(N)                       #B(t)=T(t)*N(t)
    kappa=norm_Tp/norm_rp  #K(t)=|T'(t)|/|r'(t)|
    crossing=r_prime.cross(r_pprime)
    norm_crossing=(sp.sqrt(crossing.dot(crossing)))**2
    tau = (r_prime.cross(r_pprime)).dot(r_ppprime) / norm_crossing
    #Taw=(r'*r'').r'''/|r'*r''|^2
    return T, N, B, kappa, tau

def results(name, T, N, B, kappa, tau):
    print(f'\n{name}')
    print('Tangent Vector T(t):')
    sp.pprint(T)
    print('\nNormal Vector N(t):')
    sp.pprint(N)
    print('\nBinormal Vector B(t):')
    sp.pprint(B)
    print('\nCurvature κ(t):')
    sp.pprint(kappa)
    print('\nTorsion τ(t):')
    sp.pprint(tau)
    print('\n' + '-'*50)

# Compute for both curves
T1, N1, B1, kappa1, tau1 = compute_frenet_serret(r1)
T2, N2, B2, kappa2, tau2 = compute_frenet_serret(r2)

# Display results using the function
results('(i) Curve 1: Exponential Helix', T1, N1, B1, kappa1, tau1)
results('(ii) Curve 1: Exponential Helix', T2, N2, B2, kappa2, tau2)

##plotting
t1=np.linspace(0,2*np.pi,100)
k1_np=sp.lambdify(t,kappa1,'numpy')
k2_np=sp.lambdify(t,kappa1,'numpy')
k1=k1_np(t1)
k2=k2_np(t1)
plt.plot(t1,k1,k2)
plt.xlabel('t')
plt.ylabel('Curvature')
plt.title('Curvature vs t')
plt.show()

(b)
import sympy as sp
from sympy import symbols,diff,sin,cos

x, y = sp.symbols('x y')
f = y**2 * sp.cos(x - y)
# Compute partial derivatives
fx = sp.diff(f, x)
fy = sp.diff(f, y)
fxx = sp.diff(fx, x)
fyy = sp.diff(fy, y)
fxy = sp.diff(fx, y)
fyx = sp.diff(fy, x)

print("\nSecond derivatives:")
print("f_xx =")
sp.pprint(fxx)
print("\nf_yy =")
sp.pprint(fyy)

laplacian = sp.simplify(fxx + fyy)
print("\nLaplacian f_xx + f_yy =")
sp.pprint(laplacian)

# Check Laplace's equation
if laplacian == 0:
    print("\nf satisfies Laplace's equation.")
else:
    print("\nf does not satisfy Laplace's equation.")

# Check Cauchy-Riemann (only makes sense if f is complex, still we check formally)
u = f
v = 0  # Since f is purely real
ux = sp.diff(u, x)
uy = sp.diff(u, y)
vx = sp.diff(v, x)
vy = sp.diff(v, y)

print("\nCauchy-Riemann equations check:")
cr1 = sp.simplify(ux - vy)
cr2 = sp.simplify(uy + vx)

if cr1 == 0 and cr2 == 0:
    print("Cauchy-Riemann equations are satisfied.")
else:
    print("Cauchy-Riemann equations are not satisfied.")
#part 3
print("\nf_xy =")
sp.pprint(fxy)
print("\nf_yx =")
sp.pprint(fyx)

if sp.simplify(fxy - fyx) == 0:
    print("\nMixed partial derivatives are equal: f_xy = f_yx")
else:
    print("\nMixed partial derivatives are not equal.")


(c)
import sympy as sp
import numpy as np

t,x,y,z,X,Y,Z=sp.symbols('t x y z X Y Z')
#chain rule: dw/dt=dw/dx*dx/dt+dw/dy*dy/dt+dw/dz*dz/dt
w=sp.sqrt(X**2+Y**2+Z**2)
wx=w.diff(X)
wy=w.diff(Y)
wz=w.diff(Z)

x=sp.cos(t)
y=sp.sin(t)
z=sp.tan(t)
xt=x.diff(t)
yt=y.diff(t)
zt=z.diff(t)

wx_t = wx.subs({X: x, Y: y, Z: z})
wy_t = wy.subs({X: x, Y: y, Z: z})
wz_t = wz.subs({X: x, Y: y, Z: z})

chain_formula=wx_t*xt+wy_t*yt+wz_t*zt
print('dw/dt:\n')
sp.pprint(chain_formula)
chain_formula_np=sp.lambdify(t,chain_formula,modules='numpy')
derivative=chain_formula_np(np.pi/4)
print(f'at t=pi/4, dw/dt(pi/4=)',derivative)

d)
import sympy as sp
import numpy as np
import matplotlib.pyplot as plt

x, y = sp.symbols('x y')
T = 3 * x**2 * y
# Compute gradient
grad_T = sp.Matrix([sp.diff(T, x), sp.diff(T, y)])
# Evaluate gradient at (-1, 3/2)
grad_t0 = grad_T.subs({x: -1, y: 3/2})
print("Gradient at (-1, 3/2):", grad_t0)

# Direction vector (2D!)
v0 = sp.Matrix([-1, -1/2])
v0 = v0 / v0.norm()  # normalize it
# Compute directional derivative at point
dir_deriv_at_point = grad_t0.dot(v0)
print("Directional derivative at (-1, 3/2) in direction (-1, -1/2):", dir_deriv_at_point)

#Plotting
# General directional derivative expression
D_derivative = grad_T.dot(v0)
D_derivative_np = sp.lambdify((x, y), D_derivative, 'numpy')# Convert to numpy function
x_vals = np.linspace(-2, 0, 100)
y_vals = np.linspace(0, 2, 100)
X, Y = np.meshgrid(x_vals, y_vals)
D_vals = D_derivative_np(X, Y)

#3D surface plot
fig = plt.figure(figsize=(12, 6))
ax = fig.add_subplot(121, projection='3d')
ax.plot_surface(X, Y, D_vals, cmap='viridis')
ax.set_title('Directional Derivative Surface')
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_zlabel('Value')

# Contour plot
ax2 = fig.add_subplot(122)
contour = ax2.contourf(X, Y, D_vals, cmap='viridis')
plt.colorbar(contour, ax=ax2)
ax2.set_title('Directional Derivative Contour')
ax2.set_xlabel('x')
ax2.set_ylabel('y')
plt.tight_layout()
plt.show()


#4. (a) Sketch the contour plots of (i) f(x,y) = 4x^2 + y^2 (ii) f(x,y,z) = z^2 - x^2 - y^2 using level curves of height k = 1, 4, 9, 16, 26, 36.

(b) Consider the functions:
    (i) f(x,y) = y^2 - 2y cos(x); 1 <= x <= 7
    (ii) f(x,y) = |sin(x) sin(y)|; 0 <= x <= 2pi, 0 <= y <= 2pi
    Plot the three dimensional figures with python and Matplotlib to get a better visualization.

(c) Locate all relative extrema and saddle points of the following functions:
    (i) f(x,y) = 4xy - x^4 - y^4 and (ii) f(x,y) = 4x^2 e^y - 2x^4 - e^(4y).
    Confirm that your obtained results are consistent with graphs.

(a)import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-8, 8, 400)
y = np.linspace(-8, 8, 400)
X, Y = np.meshgrid(x, y)
levels = [1, 4, 9, 16, 25, 36]

# i)
Z1 = 4 * X**2 + Y**2
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
cont1 = plt.contour(X, Y, Z1, levels=levels, cmap='viridis')
plt.clabel(cont1, inline=True, fontsize=8)  # Show level values on curves
plt.colorbar(cont1)
plt.title(r'Contour Plot of $f(x,y)=4x^2 + y^2$')
plt.xlabel('x')
plt.ylabel('y')
plt.axis('equal')

# ii) f(x, y, z) = z^2 - x^2 - y^2 → x^2 + y^2 = z^2 - k (fix z^2)
plt.subplot(1, 2, 2)
z_fixed = 7  # Let's fix z = 7 ⇒ z^2 = 49
z2_value = z_fixed**2
# Plot level curves for each k
for k in levels:
    rhs = z2_value - k
    if rhs > 0:
        radius = np.sqrt(rhs)# Circle: x^2 + y^2 = r^2
        Z2 = X**2 + Y**2
        cs = plt.contour(X, Y, Z2, levels=[rhs], colors='black')#cs=contour surface
        plt.clabel(cs, fmt={rhs: f'k={k}'}, fontsize=8)

plt.title(r'Level Curves of $f(x,y,z) = z^2 - x^2 - y^2$ (with $z=7$)')
plt.xlabel('x')
plt.ylabel('y')
plt.axis('equal')
plt.grid(True)
plt.tight_layout()
plt.show()


(bi)
import numpy as np
import matplotlib.pyplot as plt
#from mpl_toolkits.mplot3d import Axes3D # Explicitly import Axes3D for clarity

x = np.linspace(1, 7, 100)
y = np.linspace(-5, 5, 100)
X, Y = np.meshgrid(x, y)

# Directly calculate Z using the meshgrid arrays
Z = Y**2 - 2 * Y * np.cos(X)
fig = plt.figure(figsize=(10, 8)) # Added figsize for better control
ax = fig.add_subplot(111, projection='3d') # Use add_subplot for clarity

ax.plot_surface(X, Y, Z, cmap='viridis')
#ax.set_xlabel('X')
#ax.set_ylabel('Y')
plt.xlabel('X')
plt.ylabel('Y')
#plt.zlabel('f(x,y)')
ax.set_zlabel('f(x,y)')
ax.set_title('3D plot of $f(x,y)=y^2-2y\\cos(x)$') # Use double backslash for LaTeX in title

plt.show()

b(ii)
import numpy as np
import matplotlib.pyplot as plt
#from mpl_toolkits.mplot3d import Axes3D # Explicitly import Axes3D for clarity

x = np.linspace(0, 2 * np.pi, 100) # Adjusted range as per problem 4.b.i
y = np.linspace(0, 2 * np.pi, 100) # Adjusted range as per problem 4.b.i
X, Y = np.meshgrid(x, y)

# Directly calculate Z using the meshgrid arrays (FIXED LINE)
# Z must be a 2D array corresponding to the 2D X and Y meshgrids
Z = np.abs(np.sin(X) * np.cos(Y))

fig = plt.figure(figsize=(10, 8)) # Added figsize for better control
ax = fig.add_subplot(111, projection='3d') # Use add_subplot for clarity

ax.plot_surface(X, Y, Z, cmap='viridis')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('f(x,y)')
ax.set_title('3D plot of $f(x,y)=|\\sin(x)\\cos(y)|$') # Use double backslash for LaTeX in title

plt.show()


c(i)

import sympy as sp
import numpy as np
import matplotlib.pyplot as plt

x, y = sp.symbols('x y')
f_sym = 4*x*y - x**4 - y**4
fx = sp.diff(f_sym, x)
fy = sp.diff(f_sym, y)
fxx = sp.diff(fx, x)
fyy = sp.diff(fy, y)
fxy = sp.diff(fx, y)
# Critical points
cp = sp.solve([fx, fy], [x, y])
# Discriminant
D_expr = fxx*fyy - fxy**2
# Classification
saddle = []
maxima = []
minimum=[]
for i in cp:
    x_val, y_val = i
    # Skip complex solutions
    if sp.im(x_val) != 0 or sp.im(y_val) != 0:
        continue

    D_val = D_expr.subs({x: x_val, y: y_val}).evalf()
    fxx_val = fxx.subs({x: x_val, y: y_val}).evalf()

    if D_val < 0:
        saddle.append(i)
    elif D_val > 0 and fxx_val < 0:
        maxima.append(i)
    elif D_val>0 and fxx_val>0:
        minimum.append(i)

print("Saddle Points:", saddle)
print("Local Maxima:", maxima)
print("Local Minimum:", minimum)

# Plotting the surface
f_num = sp.lambdify((x, y), f_sym, 'numpy')#converting symbolic to numeric
x_vals = np.linspace(-2, 2, 100)
y_vals = np.linspace(-2, 2, 100)
X, Y = np.meshgrid(x_vals, y_vals)
Z = f_num(X, Y)

fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, Z, cmap='viridis', alpha=0.9)

# Mark critical points  #(x,y)=pt(0,1)
for pt in saddle:
    ax.scatter(float(pt[0]), float(pt[1]), f_num(float(pt[0]), float(pt[1])), color='r', label='Saddle Point')
for pt in maxima:
    ax.scatter(float(pt[0]), float(pt[1]), f_num(float(pt[0]), float(pt[1])), color='b', label='Local Max')

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('f(x, y)')
plt.title("Surface plot of f(x, y) = 4xy - x⁴ - y⁴")
plt.legend()
plt.show()


c(ii)
import sympy as sp
import numpy as np
import matplotlib.pyplot as plt

x, y = sp.symbols('x y')
f_sym = 4*x**2*sp.exp(y) -2*x**4 - sp.exp(4*y)
fx = sp.diff(f_sym, x)
fy = sp.diff(f_sym, y)
fxx = sp.diff(fx, x)
fyy = sp.diff(fy, y)
fxy = sp.diff(fx, y)
# Critical points
cp = sp.solve([fx, fy], [x, y])
# Discriminant
D_expr = fxx*fyy - fxy**2
# Classification
saddle = []
maxima = []
minimum=[]
for i in cp:
    x_val, y_val = i
    # Skip complex solutions
    if sp.im(x_val) != 0 or sp.im(y_val) != 0:
        continue

    D_val = D_expr.subs({x: x_val, y: y_val}).evalf()
    fxx_val = fxx.subs({x: x_val, y: y_val}).evalf()

    if D_val < 0:
        saddle.append(i)
    elif D_val > 0 and fxx_val < 0:
        maxima.append(i)
    elif D_val>0 and fxx_val>0:
        minimum.append(i)

print("Saddle Points:", saddle)
print("Local Maxima:", maxima)
print("Local Minimum:", minimum)

# Plotting the surface
f_num = sp.lambdify((x, y), f_sym, 'numpy')#converting symbolic to numeric
x_vals = np.linspace(-2, 2, 100)
y_vals = np.linspace(-2, 2, 100)
X, Y = np.meshgrid(x_vals, y_vals)
Z = f_num(X, Y)

fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, Z, cmap='viridis', alpha=0.9)

# Mark critical points  #(x,y)=pt(0,1)
for pt in saddle:
    ax.scatter(float(pt[0]), float(pt[1]), f_num(float(pt[0]), float(pt[1])), color='r', label='Saddle Point')
for pt in maxima:
    ax.scatter(float(pt[0]), float(pt[1]), f_num(float(pt[0]), float(pt[1])), color='b', label='Local Max')

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('f(x, y)')
plt.title("Surface plot of f(x, y) = 4x^2*exp(y)- 2*x⁴ - exp(4*y)")
plt.legend()
plt.show()

#5. (a) Consider the ellipsoid x^2 + 4y^2 + z^2 = 18
    i. Find an equation of the tangent plane to the ellipsoid at the point (1, 2, 1).
    ii. Find parametric equations of the line that is normal to the ellipsoid at the point (1, 2, 1).
    iii. Find the acute angle that the tangent plane at the point (1, 2, 1) makes with the xy-plane.
    iv. Visualize the obtained results.

(b) A space probe has the shape of an ellipsoid 4x^2 + y^2 + 4z^2 = 16 and after sitting in the sun for an hour, the temperature on its surface is given by T(x,y) = 8x^2 + 4yz - 16z + 600. Apply Lagrange multipliers approach to find the hottest point on the surface.


a)
import numpy as np
import sympy as sp
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
x,y,z=sp.symbols('x y z')
ellipsoid_eq=x**2+4*y**2+z**2-18
#(i)
point=(1,2,1)
grad_f=[sp.diff(ellipsoid_eq,var) for var in (x,y,z)]
normal_vector=[expr.subs({x:point[0],y:point[1],z:point[2]}) for expr in grad_f]
tangent_plane_eq=normal_vector[0]*(x-point[0])+normal_vector[1]*(y-point[1])+normal_vector[2]*(z-point[2])
print("Equation of tangent plane:",tangent_plane_eq)
#(ii)
t=sp.symbols('t')
normal_line=[point[i]+t*normal_vector[i] for i in range(3)]
print("normal line:",normal_line)
#(iii)
angle=sp.acos(abs(normal_vector[2])/sp.sqrt(sum(n**2 for n in normal_vector)))
angle_deg=sp.deg(angle)
print("Angle:",angle_deg.evalf())
#(iv)
fig=plt.figure(figsize=(8,6))
ax=fig.add_subplot(111,projection='3d')
u=np.linspace(0,2*np.pi,50)
v=np.linspace(0,np.pi,50)          #x^2/(a^2)+y^2/(b^2)+z^2/(c^2)=1
X=np.outer(np.cos(u),np.sin(v))*np.sqrt(18)       #x=a*cos(u)sin(v)
Y=np.outer(np.sin(u),np.sin(v))*np.sqrt(18)/2     #y=b*sin(u)*sin(v)
Z=np.outer(np.ones_like(u),np.cos(v))*np.sqrt(18) #z=c*cos(v)
ax.plot_surface(X,Y,Z,color='c',alpha=0.6)
#tangent plane
X_t,Y_t=np.meshgrid(np.linspace(-5,5,10),np.linspace(-5,5,10))
Z_t=(normal_vector[0]*(X_t-point[0])+normal_vector[1]*(Y_t-point[1]))/(-normal_vector[2])+point[2]
ax.plot_surface(X_t,Y_t,Z_t,color='r',alpha=0.5)
#normal line
t_vals=np.linspace(-5,5,10)
X_n=point[0]+t_vals*normal_vector[0]
Y_n=point[1]+t_vals*normal_vector[1]
Z_n=point[2]+t_vals*normal_vector[2]
ax.plot(X_n,Y_n,Z_n,'k--',label="Normal Line")
ax.scatter(*point,color='r',s=100,label='Point(1,2,1)')
ax.set_xlabel('X')
ax.set_ylabel('y')
ax.set_zlabel('z')
plt.show()

b)
import numpy as np
import sympy as sp
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

x, y, z, lamb = sp.symbols('x y z lamb')
T = 8*x**2 + 4*y*z - 16*z + 600
g = 4*x**2 + y**2 + 4*z**2 - 16
grad_T = sp.Matrix([sp.diff(T, var) for var in (x, y, z)])
grad_g = sp.Matrix([sp.diff(g, var) for var in (x, y, z)])
equations = [grad_T[i] - lamb * grad_g[i] for i in range(3)] + [g]
solutions = sp.solve(equations, (x, y, z, lamb), dict=True)
max_temp = -np.inf
hottest_point = None
for sol in solutions:
    temp = T.subs(sol)
    if temp > max_temp:
        max_temp = temp
        hottest_point = sol

print("Hottest Point:", hottest_point)
print("Maximum Temperature:", max_temp)

# Check constraint  #no need for this part to show
check = g.subs(hottest_point)
print("Constraint check (should be 0):", check.simplify())
print("Is on surface?", np.isclose(float(check), 0))

#Plotting
hottest_x = float(hottest_point[x])
hottest_y = float(hottest_point[y])
hottest_z = float(hottest_point[z])
# Ellipsoid surface
u = np.linspace(0, 2*np.pi, 50)
v = np.linspace(0, np.pi, 25)
U, V = np.meshgrid(u, v)
# Correct parametric ellipsoid (a=2, b=4, c=2)
X = 2 * np.cos(U) * np.sin(V)
Y = 4 * np.sin(U) * np.sin(V)
Z = 2 * np.cos(V)
# Plot
fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, Z, color='lightblue', alpha=0.7)
ax.scatter(hottest_x, hottest_y, hottest_z, color='red', s=100, label='Hottest Point')
ax.text(hottest_x, hottest_y, hottest_z, "Max", color='black')
ax.set_xlabel('X-axis')
ax.set_ylabel('Y-axis')
ax.set_zlabel('Z-axis')
ax.set_title('Space Probe Temperature Analysis')
ax.legend()
plt.show()


#6. (a) Compute the integrals:
    (i) Integral from 0 to 1 of (Integral from 0 to (1 - x^2)) of (Integral from 0 to (1 - x^2 + x^2 - y^2)) of x * e^(-y) * cos(z) dz dy dx
    (ii) Double integral over R of (xy / sqrt(x^2 + y^2 + 1)) dA; where R = {(x,y) : 0 <= x <= 1, 0 <= y <= 1}.

(b) Find the surface area of that portion of the surface z = sqrt(4 - x^2) that lies above the rectangle R in the xy-plane whose coordinates satisfy 0 <= x <= 1 and 0 <= y <= 4.

(c) Find the volume of the solid that lies below the paraboloid z = 4 - x^2 - y^2, above the xy-plane, and inside the cylinder (x - 1)^2 + y^2 = 1.

a)
import sympy as sp #need verificatin
import matplotlib.pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
from scipy.integrate import tplquad, dblquad

x, y, z, r, theta = sp.symbols('x y z r theta')
# (a) Triple Integral
f1 = lambda z, y, x: x * np.exp(-y) * np.cos(z)
sol1 = tplquad(f1, 0, 1, lambda x: 0, lambda x: 1 - x**2, lambda x, y: 3, lambda x, y: 4 - x**2 - y**2)[0]
print("Value of the first integral (numerical):", sol1)
# (b) Double Integral
f2 = lambda y, x: (x * y) / np.sqrt(x**2 + y**2 + 1)
sol2 = dblquad(f2, 0, 1, lambda x: 0, lambda x: 1)[0]
print("Value of the second integral (numerical):", sol2)
# ------------------ Visualization ------------------
fig = plt.figure(figsize=(12, 5))
ax1 = fig.add_subplot(121, projection='3d')
X = np.linspace(0, 1, 50)
Y = np.linspace(0, 1, 50)
X, Y = np.meshgrid(X, Y)
Z_upper = 4 - X**2 - Y**2
Z_lower = 3
mask = Y <= 1 - X**2# Make sure we restrict Y to be <= 1 - X^2
X_masked = np.ma.masked_where(~mask, X)#You create a valid domain region defined by y≤1−x^2, and mask out (hide) all points outside this region from X and Y.
Y_masked = np.ma.masked_where(~mask, Y)
Z_val = X_masked * np.exp(-Y_masked) * np.cos(Z_lower)  # Just show integrand at z=3
surf = ax1.plot_surface(X_masked, Y_masked, Z_val, cmap='viridis', edgecolor='none')
ax1.set_title("Integrand of Triple Integral at z=3")
ax1.set_xlabel("x")
ax1.set_ylabel("y")
ax1.set_zlabel("f(x,y,3)")
fig.colorbar(surf, ax=ax1, shrink=0.5)
# 2nd subplot: Double integral surface
ax2 = fig.add_subplot(122, projection='3d')
X2 = np.linspace(0, 1, 50)
Y2 = np.linspace(0, 1, 50)
X2, Y2 = np.meshgrid(X2, Y2)
Z2 = (X2 * Y2) / np.sqrt(X2**2 + Y2**2 + 1)
surf2 = ax2.plot_surface(X2, Y2, Z2, cmap='plasma', edgecolor='none')
ax2.set_title("Integrand of Double Integral")
ax2.set_xlabel("x")
ax2.set_ylabel("y")
ax2.set_zlabel("f(x,y)")
fig.colorbar(surf2, ax=ax2, shrink=0.5)
plt.tight_layout()
plt.show()

b)
import sympy as sp
import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import dblquad

x, y = sp.symbols('x y')
z = sp.sqrt(4 - x**2)
z_x = sp.diff(z, x)
integrand = sp.sqrt(1 + z_x**2)
f = sp.lambdify(x, integrand, 'numpy')
surface_area = dblquad(lambda y, x: f(x), 0, 1, lambda x: 0, lambda x: 4)[0]
print("Surface area:", surface_area)

# Visualization
X = np.linspace(0, 1, 100)
Y = np.linspace(0, 4, 100)
X, Y = np.meshgrid(X, Y)
Z = np.sqrt(4 - X**2)

fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(111, projection='3d')
surf = ax.plot_surface(X, Y, Z, cmap='viridis')
plt.title('Surface plot of z = sqrt(4 - x^2)')
fig.colorbar(surf)
plt.show()

c)
import sympy as sp
import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import dblquad
from mpl_toolkits.mplot3d import Axes3D

x, y ,r,theta= sp.symbols('x y r theta')
z=4-x**2-y**2                        #integrating over a disk of radius 1 centered at (1, 0).
volume=sp.integrate(sp.integrate(z.subs({x:r*sp.cos(theta)+1,y:r*sp.sin(theta)})*r,(r,0,1)),(theta,0,2*sp.pi))
print(f'volume:',volume)   #The extra r comes from the Jacobian determinant when converting to polar coordinates
# -----------------Visualization---------------------------
X = np.linspace(0, 2, 100)
Y = np.linspace(-1, 1, 100)
X, Y = np.meshgrid(X, Y)
Z = 4 - X**2 - Y**2
fig = plt.figure(figsize=(12, 7))
ax = fig.add_subplot(111, projection='3d')
surf = ax.plot_surface(X, Y, Z, cmap='viridis')
plt.title('Paraboloid z = 4 - x^2 - y^2 inside the cylinder')
fig.colorbar(surf)
# Cylinder visualization
theta = np.linspace(0, 2 * np.pi, 100)
x_cyl = 1 + np.cos(theta)
y_cyl = np.sin(theta)
z_cyl = np.linspace(0, 4, 100)
X_cyl, Z_cyl = np.meshgrid(x_cyl, z_cyl)
Y_cyl, _ = np.meshgrid(y_cyl, z_cyl)
ax.plot_surface(X_cyl, Y_cyl, Z_cyl, color='orange', alpha=0.6)
plt.show()

#7. (a) Suppose that the temperature in degrees Celsius at a point (x, y) on a flat metal plate is described as T(x,y) = 10 - 8x^2 - 2y^2, where x and y are in meters. Find the average temperature of the rectangular portion of the plate for which 0 <= x <= 1 and 0 <= y <= 2.

(b) Evaluate the line integral of (xy + z^3) ds from (1,0,0) to (-1,0,pi) along the helix C that is represented by the parametric equations x = cos(t), y = sin(t), z = t (0 <= t <= pi).

(c) Find the mass of a cylinder with radius r and height h centered at origin with density rho(x,y) = x^2 + y^2.

(d) Let F(x,y) = e^y i + x*e^y j denotes a force field in the xy-plane.
    i. Verify that the force field F(x,y) is conservative on the entire xy-plane.
    ii. Find a potential function.
    iii. Find the work done by the field on a particle that moves from (1,0) to (-1,0) along the semicircular path C.

a)
import sympy as sp
import matplotlib.pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import Axes3D

x, y = sp.symbols('x y')
T = 10 - 8*x**2 - 2*y**2
# Double integral for average temperature
area = (1 - 0) * (2 - 0)
T_avg = (1 / area) * sp.integrate(sp.integrate(T, (y, 0, 2)), (x, 0, 1))
print(f"The average temperature is: {T_avg} degrees Celsius")
#------------------Visualization--------------------------------
x_vals = np.linspace(0, 1, 100)
y_vals = np.linspace(0, 2, 100)
X, Y = np.meshgrid(x_vals, y_vals)
Z = 10 - 8*X**2 - 2*Y**2

fig = plt.figure(figsize=(10, 6))
ax = fig.add_subplot(111, projection='3d')
surf = ax.plot_surface(X, Y, Z, cmap='viridis', alpha=0.8)
ax.set_xlabel('x (meters)')
ax.set_ylabel('y (meters)')
ax.set_zlabel('Temperature (°C)')
plt.title('Temperature Distribution on the Plate')
plt.colorbar(surf, ax=ax, shrink=0.5, aspect=5)
plt.show()


b)
import sympy as sp
import matplotlib.pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import Axes3D

t = sp.symbols('t')
x = sp.cos(t)
y = sp.sin(t)
z = t
f = x * y + z**3
dx_dt = sp.diff(x, t)
dy_dt = sp.diff(y, t)
dz_dt = sp.diff(z, t)
ds = sp.sqrt(dx_dt**2 + dy_dt**2 + dz_dt**2)# Arc length: ds=sqrt((dx/dt)^2+(dy/dt)^2+(dz/dt)^2)dt
# Line integral: ∫(f(x, y, z) * ds) from t=0 to t=pi
integrand = f * ds
result = sp.integrate(integrand, (t, 0, sp.pi))
# Convert symbolic expressions to numpy functions for plotting
t_vals = np.linspace(0, np.pi, 100)
x_vals = np.cos(t_vals)
y_vals = np.sin(t_vals)
z_vals = t_vals
# Calculate the midpoint of the curve (at t = pi/2)
t_mid = np.pi / 2
x_mid = np.cos(t_mid)
y_mid = np.sin(t_mid)
z_mid = t_mid
# Calculate the direction from the start to the end
arrow_dx = x_vals[-1] - x_vals[0]
arrow_dy = y_vals[-1] - y_vals[0]
arrow_dz = z_vals[-1] - z_vals[0]
# Plot the helix
fig = plt.figure(figsize=(10, 6))
ax = fig.add_subplot(111, projection='3d')
ax.plot(x_vals, y_vals, z_vals, label='Helix: x=cos(t), y=sin(t), z=t', color='b')
# Highlight start and end points
ax.scatter([1, -1], [0, 0], [0, np.pi], color='red', s=50, label='Start (1,0,0) and End (-1,0,pi)')
# Add a single arrow at the midpoint indicating the direction from start to end
ax.quiver(x_mid, y_mid, z_mid, 
          arrow_dx, arrow_dy, arrow_dz, 
          color='black', length=0.6, normalize=True)
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_zlabel('z')
plt.title('Helix Curve for Line Integral with Direction Arrow')
plt.legend()
plt.show()
print(f"The value of the line integral is: {result}")


c)
import sympy as sp
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

R, H, r, theta, z = sp.symbols('R H r theta z')
rho = r**2 # The density function in cylindrical coordinates is rho = r^2
mass_integral = sp.integrate(rho * r, (z, -H/2, H/2), (r, 0, R), (theta, 0, 2*sp.pi))
print(f"Symbolic mass of the cylinder: {mass_integral}")
#--------------------Visualization-------------------------------------
# Now calculate it for R = 2 and H = 4
R_value = 2
H_value = 4
mass_numeric = mass_integral.subs({R: R_value, H: H_value})
# Create a grid for the cylinder
theta_vals = np.linspace(0, 2 * np.pi, 100)
r_vals = np.linspace(0, R_value, 100)
z_vals = np.linspace(-H_value/2, H_value/2, 100)
theta_vals, r_vals = np.meshgrid(theta_vals, r_vals)
x_vals = r_vals * np.cos(theta_vals)
y_vals = r_vals * np.sin(theta_vals)
z_vals = np.tile(z_vals, (len(r_vals), 1))
# Calculate the density at each point (x, y) in cylindrical coordinates
rho_vals = x_vals**2 + y_vals**2
# Plot the cylinder with the density coloring
fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(111, projection='3d')
surf = ax.plot_surface(x_vals, y_vals, z_vals, cmap='inferno',alpha=0.8)
cbar = fig.colorbar(surf)
cbar.set_label('Density (rho(x, y))')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title(f'Cylinder with Density Distribution (R={R_value}, H={H_value})')
plt.show()

d)
import numpy as np
import sympy as sp
import matplotlib.pyplot as plt

x, y = sp.symbols('x y')
f = sp.Matrix([sp.exp(y), x*sp.exp(y)])
p = f[0, 0]
q = f[1, 0]

# i) Check if force field is conservative
py = sp.diff(p, y)
qx = sp.diff(q, x)
if sp.simplify(py - qx) == 0:
    print('The force field is conservative on entire xy plane')
else:
    print('The force field is not conservative on entire xy plane')

# ii) Find potential function phi(x,y)
phi_partial = sp.integrate(p, x)  # Integrate P w.r.t x
C = sp.Function('C')(y)            # Unknown function of y
phi = phi_partial + C
dphi_dy = sp.diff(phi, y)          # Differentiate phi w.r.t y
eq = sp.Eq(dphi_dy, q)             # Equation dphi/dy = Q
C_prime = sp.simplify(sp.solve(eq, C.diff(y))[0]) # Solve for C'(y)
C_func = sp.integrate(C_prime, y)
phi = phi_partial + C_func
print('Potential function:')
sp.pprint(phi)

# iii) Compute work done from (1,0) to (-1,0)
start = {x: 1, y: 0}
end = {x: -1, y: 0}
phi_start = phi.subs(start)
phi_end = phi.subs(end)
work_done = phi_end - phi_start
print(f"Work done by the field: {work_done}")

# -------------- visualization ----------------------
# Define semicircular path from (1,0) to (-1,0)
theta = np.linspace(0, np.pi, 100)
x_vals = np.cos(theta)
y_vals = np.sin(theta)

# Create lambdified functions for numeric evaluation of Fx, Fy
Fx_func = sp.lambdify((x, y), p, 'numpy')
Fy_func = sp.lambdify((x, y), q, 'numpy')
X, Y = np.meshgrid(np.linspace(-1.5, 1.5, 20), np.linspace(-1, 1, 20))
# Evaluate vector field on grid
Fx = Fx_func(X, Y)
Fy = Fy_func(X, Y)

plt.figure(figsize=(8, 6))
plt.quiver(X, Y, Fx, Fy, color='blue', alpha=0.5, label='Force Field F(x, y)')
plt.plot(x_vals, y_vals, 'r--', label='Path C (semicircle)') # Plot semicircular path
# Add arrows along the path to indicate direction
arrow_idx = np.linspace(0, len(x_vals) - 2, 8).astype(int)
for i in arrow_idx:
    plt.annotate('', xy=(x_vals[i + 1], y_vals[i + 1]), xytext=(x_vals[i], y_vals[i]),
                 arrowprops=dict(arrowstyle='->', color='black'))

plt.scatter([1, -1], [0, 0], color='black')# Mark start and end points
plt.text(1, 0, '(1,0)', fontsize=12, verticalalignment='bottom')
plt.text(-1, 0, '(-1,0)', fontsize=12, verticalalignment='bottom')
plt.title('Force Field and Semicircular Path with Direction')
plt.legend()
plt.grid(True)
plt.show()

8. (a) Apply Green's Theorem to find the work done by the force field F(x,y) = (e^x - y^3)i + (cos(y) + x^3)j on a particle that travels once around the unit circle x^2 + y^2 = 1 in the counterclockwise direction.

(b) Evaluate the surface integral of x^2 dS over the sphere x^2 + y^2 + z^2 = 1.

(c) Use the Divergence Theorem to find the outward flux of the vector field F(x,y) = x^3 i + y^3 j + z^2 k across the surface of the region that is enclosed by the circular cylinder x^2 + y^2 = 9 and the planes z = 0 and z = 2.

(d) Verify Stoke's Theorem for the vector field F(x,y,z) = 2z i + 3x j + 5y k taking S to be the portion of the paraboloid z = 4 - x^2 - y^2 for which z >= 0 with upward orientation, and C to be the positively oriented circle x^2 + y^2 = 4 that forms the boundary of S in the xy-plane.


a)
import sympy as sp
import numpy as np
import matplotlib.pyplot as plt

x, y, z,r,theta= sp.symbols('x y z r theta')
P = sp.exp(x) - y**3
Q = sp.cos(y) + x**3
curl_F = sp.diff(Q, x) - sp.diff(P, y) # curl F = dQ/dx - dP/dy
# Unit circle area integral so x=1*cos(theta) and y=sin(theta)
dA = r
integral = sp.integrate(sp.integrate(curl_F.subs({x: r*sp.cos(theta), y: r*sp.sin(theta)}) * dA, (r, 0, 1)), (theta, 0, 2*sp.pi))
print("(a) Work done by the force field:", integral)  
# ---------------- Visualization ----------------
P_func = sp.lambdify((x, y), P, 'numpy')
Q_func = sp.lambdify((x, y), Q, 'numpy')
X, Y = np.meshgrid(np.linspace(-1.5, 1.5, 25), np.linspace(-1.5, 1.5, 25))
U = P_func(X, Y)
V = Q_func(X, Y)
plt.figure(figsize=(8, 8))
# Plot vector field using quiver
plt.quiver(X, Y, U, V, color='blue', alpha=0.6, label='Vector field F')
# Plot unit circle boundary (path C)
theta_vals = np.linspace(0, 2*np.pi, 200)
circle_x = np.cos(theta_vals)
circle_y = np.sin(theta_vals)
plt.plot(circle_x, circle_y, 'r--', linewidth=2, label='Boundary curve C (unit circle)')
# Add arrows along the boundary to show orientation
arrow_idx = np.linspace(0, len(theta_vals)-2, 8).astype(int)
for i in arrow_idx:
    plt.annotate('', xy=(circle_x[i+1], circle_y[i+1]), xytext=(circle_x[i], circle_y[i]),
                 arrowprops=dict(arrowstyle='->', color='black'))

plt.title('Vector Field and Unit Circle Boundary')
plt.xlabel('x')
plt.ylabel('y')
plt.axis('equal')
plt.legend()
plt.grid(True)
plt.show()

b)
import sympy as sp  #need verification
import numpy as np
import matplotlib.pyplot as plt

rho, phi, theta = sp.symbols('rho phi theta')
# x = rho*sin(phi)*cos(theta), y = rho*sin(phi)*sin(theta), z = rho*cos(phi)  #rho=1(radius 1)
x_sph = rho * sp.sin(phi) * sp.cos(theta)# x^2 in spherical coordinates
jacobian = rho**2 * sp.sin(phi)# Jacobian for spherical coordinates: rho^2 * sin(phi)
x_squared = (x_sph)**2
surface_integral = sp.integrate(sp.integrate((x_squared * jacobian).subs(rho, 1), (phi, 0, sp.pi)), (theta, 0, 2*sp.pi))
print("(b) Surface integral over the sphere using spherical coordinates:", surface_integral) 

#-----------visualization-------------------
# Create a meshgrid for spherical coordinates
phi, theta = np.meshgrid(np.linspace(0, np.pi, 50), np.linspace(0, 2*np.pi, 50))
# Convert to Cartesian coordinates (unit sphere)
x = np.sin(phi) * np.cos(theta)
y = np.sin(phi) * np.sin(theta)
z = np.cos(phi)

fig = plt.figure(figsize=(6, 6))
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(x, y, z, color='c', alpha=0.6)
ax.set_xlabel("X-axis")
ax.set_ylabel("Y-axis")
ax.set_zlabel("Z-axis")
ax.set_title("Unit Sphere for Surface Integral Visualization")
plt.show()

c)
import sympy as sp
import numpy as np
import matplotlib.pyplot as plt

x, y, z = sp.symbols('x y z')
F = [x**3, y**3, z**2]
# Compute divergence
div_F = sp.diff(F[0], x) + sp.diff(F[1], y) + sp.diff(F[2], z)
print("Divergence of F:", div_F)
# Convert to cylindrical coordinates
r, theta, z = sp.symbols('r theta z')
div_F_cyl = div_F.subs({x: r*sp.cos(theta), y: r*sp.sin(theta)})
# Set up volume integral over the cylinder x² + y² ≤ 9, 0 ≤ z ≤ 2
flux = sp.integrate(sp.integrate(sp.integrate(div_F_cyl * r, (r, 0, 3)), (theta, 0, 2*sp.pi)), (z, 0, 2))
print("Outward flux of F using Divergence Theorem:", flux)

# Visualization of the enclosed cylindrical region
fig = plt.figure(figsize=(6, 6))
ax = fig.add_subplot(111, projection='3d')
# Cylinder parameters
theta_vals = np.linspace(0, 2*np.pi, 100)
z_vals = np.linspace(0, 2, 50)
theta_vals, z_vals = np.meshgrid(theta_vals, z_vals)
r_vals = 3  # Radius of cylinder
# Convert to Cartesian coordinates
X = r_vals * np.cos(theta_vals)
Y = r_vals * np.sin(theta_vals)
Z = z_vals

ax.plot_surface(X, Y, Z, color='c', alpha=0.6)
ax.set_xlabel("X-axis")
ax.set_ylabel("Y-axis")
ax.set_zlabel("Z-axis")
ax.set_title("Enclosed Cylindrical Region")
plt.show()

d)
import sympy as sp
import numpy as np
import matplotlib.pyplot as plt

x, y, z = sp.symbols('x y z')
F = [2*z, 3*x, 5*y]
curl_F = sp.Matrix([
    sp.diff(F[2], y) - sp.diff(F[1], z),
    sp.diff(F[0], z) - sp.diff(F[2], x),
    sp.diff(F[1], x) - sp.diff(F[0], y)
])
print("Curl of F:", curl_F)
# Surface integral over the paraboloid z = 4 - x^2 - y^2
r, theta = sp.symbols('r theta')
curl_F_cyl = curl_F.subs({x: r*sp.cos(theta), y: r*sp.sin(theta), z: 4 - r**2})
# Normal vector to the surface (upward orientation) is simply k-hat: (0,0,1)
flux = sp.integrate(sp.integrate(curl_F_cyl[2] * r, (r, 0, 2)), (theta, 0, 2*sp.pi))
print("Surface integral ∫∫ (curl F) ⋅ dS:", flux)
# Line integral along the circle x^2 + y^2 = 4
C_param = {x: 2*sp.cos(theta), y: 2*sp.sin(theta), z: 0}
F_C = sp.Matrix([F[i].subs(C_param) for i in range(3)])
dr_dt = sp.Matrix([
    sp.diff(C_param[x], theta), 
    sp.diff(C_param[y], theta),
    sp.diff(C_param[z], theta)
])
line_integral = sp.integrate(F_C.dot(dr_dt), (theta, 0, 2*sp.pi))
print("Line integral ∮ F ⋅ dr:", line_integral)
if flux==line_integral:
    print('Stoke''s theorem verified')
else:
    print('Stoke''s theorem not verified')
# -------------Visualization of the paraboloid--------------
fig = plt.figure(figsize=(6, 6))
ax = fig.add_subplot(111, projection='3d')
theta_vals = np.linspace(0, 2*np.pi, 100)
r_vals = np.linspace(0, 2, 50)
theta_vals, r_vals = np.meshgrid(theta_vals, r_vals)
Z = 4 - r_vals**2
X = r_vals * np.cos(theta_vals)
Y = r_vals * np.sin(theta_vals)

ax.plot_surface(X, Y, Z, color='c', alpha=0.6)
ax.set_xlabel("X-axis")
ax.set_ylabel("Y-axis")
ax.set_zlabel("Z-axis")
ax.set_title("Surface σ: Paraboloid z = 4 - x² - y²")
plt.show()


